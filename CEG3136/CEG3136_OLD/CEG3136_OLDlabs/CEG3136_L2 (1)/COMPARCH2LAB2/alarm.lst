D:\OneDrive\Fall 2017\CEG 3136 COMPUTER ARCHITECTURE II\CEG3136 COMP. ARCH. II Labs\L2\CODE\alarm.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Tue Oct 10 10:30:43 2017

    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: alarm.asm (Alarm System Module)
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
   10:                                 
   11:                                 ; Some definitions
   12:                                 ; Location of the register block
   13:          =00000000              Regblk:       equ    $0000 
   14:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =000024B1                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   15:                                  INCLUDE alarm.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff
   11:          =00000007              BEL           equ    0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   16:                                 
   17:                                 ; Dbug12 subroutines
   18:          =0000EE86              putchar        equ   $EE86
   19:          =0000EE84              getchar        equ   $EE84
   20:          =0000EE88              printf         equ   $EE88
   21:          =0000EEA6              writeEEByte    equ   $EEA6
   22:                                 
   23:                                         switch code_section
   24:                                 ;------------------------------------------------------
   25:                                 ; Alarm System Module
   26:                                 
   27:                                 ; Main routine
   28:                                 ; Variables: select - in register B (set by getchar)
   29:                                 ; Description: The main routine for running the game.
   30:                                 ;              Initialises things (via initgb) and the
   31:                                 ;              loops forever playing games.
   32:                                 ;------------------------------------------------------
   33:     2000 CF 2000                        lds #STACK       ; Not reflected in C
   34:     2003 07 27                          bsr inithw       ; initiliase the hardware
   35:     2005 16 2367                        jsr initKeyPad   ;  initKeyPad();
   36:     2008 16 24A1                        jsr initSwitches ;  initSwithes();
   37:                                         ; byte select - in register B
   38:                                                         ;do
   39:     200B                        mainloop:                       ; {
   40:     200B CC 24BB                        ldd #MENU          ;   printf(MENU);
   41:     200E 15 FB CE76                     jsr [printf,PCr] 
   42:     2012 16 23A3                        jsr readKey        ;   select = readKey();
   43:     2015 37                             pshb ; save b
   44:     2016 33                             pulb
   45:     2017 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   46:     2019 26 05                          bne mnElseif
   47:     201B 16 2062                        jsr configCodes
   48:     201E 20 09                          bra mnEndif
   49:     2020 C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   50:     2022 26 05                          bne mnElse
   51:     2024 16 21BC                        jsr enableAlarm
   52:     2027 20 00                          bra mnEndif
   53:     2029                        mnElse                     ;   else /*do nothing*/;
   54:     2029                        mnEndif:
   55:     2029 20 E0                          bra mainloop       ; } while(1);  // loop forever
   56:     202B 3F                             swi                ; never reach here - infinite loop
   57:                                 
   58:                                 ;------------------------------------------------------
   59:                                 ; Subroutine: inithw
   60:                                 ; No parameters
   61:                                 ; Variables: ptx - index register X
   62:                                 ;            pty - index register Y
   63:                                 ; Description: First setup up the microcontroller setting up the clock, 
   64:                                 ;             shutting down the COP watchdog timer, and initialising 
   65:                                 ;             the SCI serial interface. Initialises global variables also.
   66:                                 ;------------------------------------------------------
   67:     202C                        inithw:
   68:                                 ; -- Initialise the hardware
   69:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   70:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   71:                                 ;       In order to set the bus speed higher than 4 MHz the PLL must be initialized
   72:                                 ;
   73:                                 ;       The math used to set the PLL frequency is:
   74:                                 ;        
   75:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   76:                                 ;       
   77:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   78:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   79:                                 ;         initREFDV    = 0    PLL divisor will be 1
   80:                                 
   81:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   82:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   83:                                 ;
   84:                                 ;      
   85:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   86:     202C 1410                           sei
   87:     202E CE 0000                        ldx #Regblk
   88:     2031 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   89:     2035 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   90:     2039 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   91:     203B 6A E0 34                       staa Synr,x
   92:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   93:     203E 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   94:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   95:     2040 6A E0 35                       staa Refdv,x
   96:     2043                        wait_b3:
   97:     2043 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   98:     2048 0C E0 39 80                    bset Clksel,x, %10000000
   99:                                 
  100:                                         ; Setup Serial port
  101:     204C CC 009C                        ldd #156
  102:     204F 5C C8                          std Sc0bdh   ; Sets up the baud rate
  103:     2051 86 0C                          ldaa #$0c
  104:     2053 5A CB                          staa Sc0cr2  ; Enables serial interface
  105:                                         
  106:                                         ; Setup the data in the RAM
  107:                                         ; For the Configuration Module
  108:     2055 1803 0000 3002                 movw #0,alarmCode
  109:     205B 1803 03E8 3000                 movw #1000,mult
  110:     2061 3D                             rts
  111:                                 
  112:                                    switch globalConst
  113:                                 
  114:                                 ;-------------------------------------------------------------------------
  115:                                 ; Data Structures
  116:                                 ; The following data is stored in EEPROM 
  117:                                 ; Following is data array used by testWin 
  118:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  119:                                 ;------------------------------------------------------
  120:     24B1 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           24B7 FFFF FFFF 
  121:                                 
  122:                                 ; Message strings
  123:     24BB 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           24C1 36 20 41 6C 61 72 
           24C7 6D 0A 0D 63 2D 43 
           24CD 6F 6E 66 69 67 20 
           24D3 61 2D 41 72 6D 0A 
           24D9 0D 00 
  124:     24DB 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  125:                                 
  126:                                  
  127:                                 ;----------
  128:                                 ; Include other modules here
  129:                                 ;-----------
  130:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     2062 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     2063 1B 9D                        leas -CFG_VARSIZE,SP
   31:     2065 16 20A9                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     2068 97                           tsta
   33:     2069 27 3A                        beq cfg_endif1
   34:     206B                        cfg_loop:               ;     do {
   35:     206B CC 24EC                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     206E 15 FB CE16                   jsr [printf,PCr]
   37:     2072 16 23A3                      jsr readKey ;          input = readKey();
   38:     2075 6B 81                        stab CFG_INPUT,SP ;
   39:     2077 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     207B                        cfg_if2:
   41:     207B A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     207D 81 61                        cmpa #'a'
   43:     207F 26 07                        bne cfg_elseif2
   44:     2081 86 00                        ldaa #0           ;               setcode(0);
   45:     2083 16 2108                      jsr setcode
   46:     2086 20 19                        bra cfg_endif2
   47:     2088                        cfg_elseif2:
   48:     2088 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     208A 25 0A                        blo cfg_else2
   50:     208C 81 34                        cmpa #'4'
   51:     208E 22 06                        bhi cfg_else2
   52:     2090 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     2092 07 74                        bsr setcode           ;           setcode(ix); }
   54:     2094 20 0B                        bra cfg_endif2
   55:     2096                        cfg_else2:              ;           else      
   56:     2096 CC 24FF                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     2099 15 FB CDEB                   jsr [printf,PCr]  ;
   58:     209D 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     20A1                        cfg_endif2:
   60:     20A1 E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     20A3 27 C6                        beq cfg_loop
   62:     20A5                        cfg_endif1:
   63:     20A5 1B 83                        leas CFG_VARSIZE,SP
   64:     20A7 3A                           puld
   65:     20A8 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     20A9 37                     enterMstCode pshb
   87:     20AA 34                        pshx
   88:     20AB 35                        pshy
   89:     20AC 1B 99                     leas -EMC_VARSIZE,SP
   90:     20AE 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     20B2 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     20B7 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     20BC CC 24DE                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     20BF 15 FB CDC5                jsr [printf, PCr]
   98:     20C3 69 81                     clr EMC_I,SP
   99:     20C5                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     20C5 16 23A3                   jsr readKey                ; {
  101:     20C8 6B 82                     stab EMC_INPUT,SP          ;    input = readKey();
  102:     20CA                        emc_if1:
  103:     20CA 180F                      tba
  104:     20CC 16 2483                   jsr isdigit                ;    if(!isdigit(input))
  105:     20CF 97                        tsta
  106:     20D0 27 2E                     beq emc_endfor             ;         break;
  107:     20D2                        emc_else1:                    ;    else {
  108:     20D2 E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     20D4 C0 30                     subb #ASCII_CONV_NUM
  110:     20D6 87                        clra
  111:     20D7 ED 85                     ldy  EMC_MULT,SP
  112:     20D9 13                        emul
  113:     20DA E3 83                     addd EMC_ALARMCODE,SP
  114:     20DC 6C 83                     std EMC_ALARMCODE,SP
  115:     20DE EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     20E0 CE 000A                   ldx #10
  117:     20E3 1810                      idiv
  118:     20E5 6E 85                     stx EMC_MULT,SP
  119:     20E7 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     20EA 26 0B                     bne emc_endif2
  121:     20EC FC 24B1                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     20EF AC 83                     cpd EMC_ALARMCODE,SP
  123:     20F1 26 04                     bne emc_endif3
  124:     20F3 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     20F7                        emc_endif3:
  126:     20F7                        emc_endif2:                   ;       }
  127:     20F7                        emc_endif1:                   ;    }
  128:     20F7 A6 81                     ldaa EMC_I,SP
  129:     20F9 42                        inca
  130:     20FA 6A 81                     staa EMC_I,SP
  131:     20FC 81 04                     cmpa #4
  132:     20FE 25 C5                     blo emc_for
  133:     2100                        emc_endfor:                   ; }
  134:     2100 A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     2102 1B 87                     leas EMC_VARSIZE,SP
  136:     2104 31                        puly
  137:     2105 30                        pulx
  138:     2106 33                        pulb
  139:     2107 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     2108 35                     setcode: pshy       ; {
  169:     2109 34                              pshx
  170:     210A 3B                              pshd
  171:     210B 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     210D 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ;int digit;
  176:     2112 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ; int alarmCode=0;
  177:     2117 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  178:     211C 6A 80                        staa SETC_IX,SP         ; save parameter value
  179:     211E                        setc_loop:                    ; do {
  180:     211E CC 250B                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  181:     2121 15 FB CD63                   jsr [printf, PCr]
  182:     2125 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  183:     2127                        setc_for:                     ;      {
  184:     2127 16 23A3                      jsr readKey             ;         input = readKey();
  185:     212A 6B 83                        stab SETC_INPUT,SP
  186:     212C C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  187:     212E 26 1C                        bne setc_elseif         ;         { 
  188:     2130 A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  189:     2132 81 00                        cmpa #0
  190:     2134 26 09                        bne setc_else2
  191:     2136 CC 2519                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  192:     2139 15 FB CD4B                   jsr [printf,PCr]
  193:     213D 20 0B                        bra setc_endif2
  194:     213F                        setc_else2                    ;            else {
  195:     213F 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  196:     2144 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  197:     2148 20 3E                        bra setc_endfor          ;                 break; 
  198:     214A                        setc_endif2                   ;             }
  199:     214A 20 33                        bra setc_endif          ;         }
  200:     214C                        setc_elseif:
  201:     214C A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  202:     214E 16 2483                      jsr isdigit
  203:     2151 97                           tsta
  204:     2152 27 22                        beq setc_else
  205:     2154 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  206:     2156 C0 30                        subb #ASCII_CONV_NUM
  207:     2158 87                           clra
  208:     2159 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  209:     215B ED 88                        ldy SETC_MULT,SP
  210:     215D 13                           EMUL                    ; // Result digit*mult is in D
  211:     215E E3 86                        addd SETC_ALARMCODE,SP
  212:     2160 6C 86                        std SETC_ALARMCODE,SP
  213:     2162 EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  214:     2164 CE 000A                      ldx #10
  215:     2167 1810                         idiv
  216:     2169 6E 88                        stx SETC_MULT,SP
  217:     216B 8E 0000                      cpx #0                  ;            if(mult == 0)
  218:     216E 26 0F                        bne setc_endif          ;             
  219:     2170 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  220:     2174 20 09                        bra setc_endif          ;         }
  221:     2176                        setc_else:                    ;         else {
  222:     2176 CC 24FF                      ldd #CERRMSG            ;                printf(CERRMSG);
  223:     2179 15 FB CD0B                   jsr [printf, PCr]
  224:     217D 20 09                        bra setc_endfor         ;                break;
  225:                                                               ;         }
  226:     217F                        setc_endif:
  227:     217F A6 82                        ldaa SETC_I,SP
  228:     2181 42                           inca
  229:     2182 6A 82                        staa SETC_I,SP
  230:     2184 81 04                        cmpa #4
  231:     2186 25 9F                        blo setc_for 
  232:     2188                        setc_endfor:                       ;   }
  233:     2188 E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  234:     218A 26 92                        bne setc_loop
  235:     218C A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  236:     218E 48                           lsla  ; double index value - 2 bytes/element
  237:     218F CE 24B1                      ldx #alarmCodes
  238:     2192 1A E4                        leax a,x
  239:     2194 EC 86                        ldd SETC_ALARMCODE,SP
  240:     2196 07 06                        bsr writeToEE
  241:     2198 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  242:     219A 3A                           puld                    ; restore registers
  243:     219B 30                           pulx
  244:     219C 31                           puly
  245:     219D 3D                           rts
  246:                                 ;---------------------------------
  247:                                 ; Subroutine: writeToEE()
  248:                                 ; Parameters: address - in x register
  249:                                 ;             alarmCode    - in d register
  250:                                 ; Variables: none
  251:                                 ; Description:
  252:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  253:                                 ;     function avaible in Debug12.
  254:                                 ;------------------------------------------------------
  255:                                 ; Stack Usage
  256:                                         OFFSET 0 ; to setup offsets into stack
  257:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  258:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  259:     0004 +0002                  WREE_RA DS.W 1  ; return address
  260:                                 
  261:     219E 34                     writeToEE:  pshx
  262:     219F 3B                                 pshd
  263:     21A0 E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  264:     21A2 3B                                 pshd   ; save argument on stack
  265:     21A3 B7 54                              tfr x,d ; first argument passed in D
  266:     21A5 4B FB CCFD                         call [writeEEByte, PCr]
  267:     21A9 30                                 pulx  ; remove argument
  268:     21AA EE 82                              ldx WREE_PR_X,SP     ; get address
  269:     21AC E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  270:     21AE 3B                                 pshd  ; save argument on stack
  271:     21AF B7 54                              tfr x,d ; first argument passed in D
  272:     21B1 C3 0001                            addd #1 ; address+1
  273:     21B4 4B FB CCEE                         call [writeEEByte, PCr]
  274:     21B8 30                                 pulx   ; remove argument
  275:     21B9 3A                                 puld   ; restore D
  276:     21BA 30                                 pulx   ; restore X
  277:     21BB 3D                                 rts
  278:                                         
  279:                                    switch globalConst
  280:     24DE 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           24E4 20 63 6F 64 65 0A 
           24EA 0D 00 
  281:     24EC 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           24F2 20 31 2D 34 3A 6F 
           24F8 74 68 65 72 0A 0D 
           24FE 00 
  282:     24FF 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           2505 74 72 79 0A 0D 00 
  283:     250B 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           2511 72 20 27 64 27 0A 
           2517 0D 00 
  284:     2519 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           251F 20 64 69 73 61 62 
           2525 6C 65 0A 0D 00 
  285:                                 
  131:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000BB8              ARMDELAY  equ 3000; 15000
   11:          =000003E8              BEEPDELAY equ 1000
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     21BC 3B                     enableAlarm:  pshd
   40:     21BD 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     21BF CC 252A                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     21C2 15 FB CCC2                jsr [printf, PCr]
   46:     21C6 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     21CA                        eal_while1:
   48:     21CA E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     21CC 26 0E                     bne eal_endwhile1            ; {
   50:     21CE 16 23A3                   jsr readKey                  ;   input = readKey();
   51:     21D1 6B 80                     stab EAL_INPUT,SP
   52:     21D3 180F                      tba
   53:     21D5 16 229F                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     21D8 6A 81                     staa EAL_CODEVALID,SP
   55:     21DA 20 EE                     bra eal_while1
   56:     21DC                        eal_endwhile1                   ; }
   57:                                 
   58:     21DC CC 2531                   ldd #ARMING                   ; printf(ARMING);
   59:     21DF 15 FB CCA5                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     21E3 CC 0BB8                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     21E6 16 2456                   jsr setDelay
   63:     21E9 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     21ED 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     21F1                        eal_while2:                     ; while(!delayFlag) 
   66:     21F1 E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     21F3 26 28                     bne eal_endwhile2
   68:     21F5 16 245A                   jsr polldelay                ;   delayFlag = delay(); 
   69:     21F8 6A 82                     staa EAL_DELAYFLAG,SP
   70:     21FA 16 2372                   jsr pollreadKey              ;   input = pollreadKey();  // check if code entered to disarm
   71:     21FD 6B 80                     stab EAL_INPUT,SP
   72:     21FF 180F                      tba
   73:     2201                        eal_if1:
   74:     2201 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     2203 27 08                     beq eal_blk1
   76:     2205 16 2483                   jsr isdigit
   77:     2208 97                        tsta
   78:     2209 26 02                     bne eal_blk1
   79:     220B 20 0E                     bra eal_endif1   
   80:     220D                        eal_blk1:                       ;    {
   81:     220D A6 80                     ldaa EAL_INPUT,SP            
   82:     220F 16 229F                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     2212 6A 81                     staa EAL_CODEVALID,SP
   84:     2214                        eal_if2:
   85:     2214 97                        tsta                         ;        if(codeValid) 
   86:     2215 27 04                     beq eal_endif2
   87:     2217 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     221B                        eal_endif2:
   89:     221B                        eal_endif1:                     ;    }
   90:     221B 20 D4                     bra eal_while2               
   91:     221D                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     221D                        eal_if3:                        ; if(!codeValid)
   96:     221D E7 81                     tst EAL_CODEVALID,SP
   97:     221F 26 07                     bne eal_endif3
   98:     2221 CC 2542                   ldd #ARMED                   ;        printf(ARMED)
   99:     2224 15 FB CC60                jsr [printf, PCr]
  100:     2228                        eal_endif3:
  101:     2228                        eal_while3                      ;  while(!codeValid)
  102:     2228 E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     222A 26 6F                     bne eal_endwhile3
  104:     222C 16 2372                   jsr pollReadKey              ;    input = pollReadKey();
  105:     222F 6B 80                     stab EAL_INPUT,SP
  106:     2231 180F                      tba
  107:     2233                        eal_elseif
  108:     2233 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  109:     2235 27 08                     beq eal_blk2
  110:     2237 16 2483                   jsr isdigit
  111:     223A 97                        tsta
  112:     223B 26 02                     bne eal_blk2
  113:     223D 20 08                     bra eal_elseifA  
  114:     223F                        eal_blk2:      
  115:     223F A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  116:     2241 07 5C                     bsr checkCode                
  117:     2243 6A 81                     staa EAL_CODEVALID,SP 
  118:     2245 20 52                     bra eal_endelseif    
  119:     2247                        eal_elseifA:
  120:     2247 16 24AD                   jsr getSwStatus               ;   else if(getSwStatus() & 0b00000001) // Front door opened
  121:     224A 84 01                     anda #%00000001
  122:     224C 27 3D                     beq eal_elseifB               ;   {
  123:     224E CC 2552                   ldd #DISARMING                ;      printf(DISARMING);
  124:     2251 15 FB CC33                jsr [printf, PCr]
  125:     2255 CC 0BB8                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  126:     2258 16 2456                   jsr setDelay
  127:     225B                        eal_while4:                      ;      while(!codeValid)
  128:     225B A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  129:     225D 26 2A                     bne eal_endwhile4 
  130:     225F                        eal_if4:
  131:     225F 16 245A                   jsr pollDelay                 ;         if(pollDelay())
  132:     2262 97                        tsta  
  133:     2263 27 09                     beq eal_else4                 ;         { 
  134:     2265 16 2320                   jsr triggerAlarm              ;            triggerAlarm();
  135:     2268 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  136:     226C 20 19                     bra eal_endif4                ;         }
  137:     226E                        eal_else4                        ;         else {
  138:     226E 16 2372                   jsr pollReadKey               ;            input = pollReadKey();  // check if alarm code entered to disarm
  139:     2271 6B 80                     stab EAL_INPUT,SP
  140:     2273                        eal_if5:
  141:     2273 180F                      tba                           ;            if(isdigit(input) || input == '#')
  142:     2275 81 23                     cmpa #'#' 
  143:     2277 27 08                     beq eal_blk3
  144:     2279 16 2483                   jsr isdigit
  145:     227C 97                        tsta
  146:     227D 26 02                     bne eal_blk3
  147:     227F 20 06                     bra eal_endif5   
  148:     2281                        eal_blk3:  
  149:     2281 A6 80                     ldaa EAL_INPUT,SP
  150:     2283 07 1A                     bsr checkCode                ;                 codeValid = checkCode(input);
  151:     2285 6A 81                     staa EAL_CODEVALID,SP 
  152:     2287                        eal_endif5:
  153:     2287                        eal_endif4:                     ;          }
  154:     2287 20 D2                     bra eal_while4
  155:     2289                        eal_endwhile4:                  ;        }
  156:     2289                        eal_endelseifA                  ;      }
  157:     2289 20 0E                     bra eal_endelseif;      
  158:     228B                        eal_elseifB:
  159:     228B 16 24AD                   jsr getSwStatus              ;      else if(getSwStatus() & 0b11111110) // other door/window opened
  160:     228E 84 FE                     anda #%11111110              ;      
  161:     2290 27 07                     beq eal_endelseifB           ;      {
  162:     2292 16 2320                   jsr triggerAlarm             ;          triggerAlarm();
  163:     2295 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  164:     2299                        eal_endelseifB:                 ;      }
  165:                                    ;    // ignore all other input
  166:     2299                        eal_endelseif:
  167:     2299 20 8D                      bra eal_while3
  168:     229B                        eal_endwhile3                   ; }
  169:     229B 1B 83                      leas EAL_VARSIZE,SP
  170:     229D 3A                         puld
  171:     229E 3D                         rts
  172:                                 
  173:                                 
  174:                                 ;------------------------------------------------------
  175:                                 ; Subroutine: checkCode
  176:                                 ; Parameters: input - accumulator A
  177:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  178:                                 ;          accumulator A
  179:                                 ; Local Variables: retval - on stack
  180:                                 ; Global Variables:
  181:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  182:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  183:                                 ; Descriptions: Creates alarm code using digits entered until
  184:                                 ;               4 digits are seen. After 4th digit, see if
  185:                                 ;               alarm code is valid using isCodeValid().
  186:                                 ;------------------------------------------------------
  187:                                 ; Stack usage
  188:                                         OFFSET 0
  189:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  190:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  191:     0002                        CKC_VARSIZE
  192:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  193:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  194:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  195:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  196:                                 
  197:     229F 35                     checkCode: pshy
  198:     22A0 34                        pshx
  199:     22A1 37                        pshb
  200:     22A2 1B 9E                     leas -CKC_VARSIZE,SP       
  201:                                                               ; static int mult = 1000; // current multiplier of digit
  202:                                                               ; static int alarmCode = 0;   // alarm code value
  203:     22A4 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  204:     22A8 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  205:                                    
  206:     22AA 16 2483                   jsr isdigit                ; if(isdigit(input))
  207:     22AD 97                        tsta
  208:     22AE 27 36                     beq ckc_else               ; {
  209:     22B0 A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  210:     22B2 80 30                     suba #ASCII_CONV_NUM
  211:     22B4 180E                      tab                        
  212:     22B6 87                        clra
  213:     22B7 FD 3000                   ldy mult
  214:     22BA 13                        emul                       ; //*mult - result in D
  215:     22BB F3 3002                   addd alarmCode
  216:     22BE 7C 3002                   std alarmCode
  217:     22C1 FC 3000                   ldd mult                   ;    mult = mult/10;
  218:     22C4 CE 000A                   ldx #10
  219:     22C7 1810                      idiv
  220:     22C9 7E 3000                   stx mult
  221:     22CC FC 3000                   ldd mult                   ;    if(mult == 0) 
  222:     22CF 26 13                     bne ckc_endif1             ;    {
  223:     22D1 FC 3002                   ldd alarmcode              ;
  224:     22D4 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  225:     22D6 6A 81                     staa CKC_RETVAL,SP
  226:     22D8 CC 0000                   ldd #0                     ;       alarmCode = 0;
  227:     22DB 7C 3002                   std alarmCode 
  228:     22DE CC 03E8                   ldd #1000                  ;       mult = 1000;
  229:     22E1 7C 3000                   std mult     
  230:     22E4                        ckc_endif1:                   ;     }
  231:     22E4 20 0C                     bra ckc_endif              ; }
  232:     22E6                        ckc_else:                     ; else {
  233:     22E6 CC 0000                   ldd #0                     ;       alarmCode = 0;
  234:     22E9 7C 3002                   std alarmCode 
  235:     22EC CC 03E8                   ldd #1000                  ;       mult = 1000;
  236:     22EF 7C 3000                   std mult                   ; }
  237:     22F2                        ckc_endif:
  238:                                    
  239:     22F2 A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  240:                                    ; Restore registers and stack
  241:     22F4 1B 82                     leas CKC_VARSIZE,SP
  242:     22F6 33                        pulb
  243:     22F7 30                        pulx
  244:     22F8 31                        puly
  245:     22F9 3D                        rts      
  246:                                 
  247:                                 
  248:                                 ;------------------------------------------------------
  249:                                 ; Subroutine: isCodeValid
  250:                                 ; Parameters: alarmCode stored in register D
  251:                                 ; Local Variables
  252:                                 ;   ptr - pointer to array - in register X
  253:                                 ;   cnt, retval - on the stack.
  254:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  255:                                 ; Description: Checks to see if alarm code is in the
  256:                                 ;              alarmCodes array.
  257:                                 ;------------------------------------------------------
  258:                                 
  259:                                 ; Stack usage
  260:                                         OFFSET 0
  261:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  262:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  263:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  264:     0004                        CDV_VARSIZE:
  265:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  266:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  267:                                 
  268:     22FA 34                     isCodeValid: pshx
  269:     22FB 1B 9C                     leas -CDV_VARSIZE,SP
  270:     22FD 6C 80                     std CDV_ALARMCODE,SP
  271:                                    ; int *ptr;  // pointer to alarmCodes
  272:     22FF 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  273:     2303 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  274:     2307 CE 24B1                   ldx #alarmCodes           ; ptr = alarmCodes;
  275:     230A                        cdv_while                    ; do
  276:     230A EC 31                     ldd 2,X+                  ; {
  277:     230C AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  278:     230E 26 06                     bne cdv_endif             ;    {
  279:     2310 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  280:     2314 20 04                     bra cdv_endwhile          ;      break;
  281:     2316                        cdv_endif:                   ;    }
  282:     2316 63 82                     dec CDV_CNT,SP            ;   cnt--;
  283:     2318 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  284:     231A                        cdv_endwhile:
  285:     231A A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  286:                                    ; restore registers and stack
  287:     231C 1B 84                     leas CDV_VARSIZE,SP 
  288:     231E 30                        pulx
  289:     231F 3D                        rts
  290:                                 
  291:                                 ;----------------------------
  292:                                 ; Subroutine: triggerAlarm
  293:                                 ; Parameters: none
  294:                                 ; Returns: nothing
  295:                                 ; Local Variables: retval, dobel, input - on stack
  296:                                 ; Description: Repeatedly sends a bel character to the
  297:                                 ;              terminal until a valid alarm code is entered.
  298:                                 ;----------------------------
  299:                                 ; Stack usage
  300:                                         OFFSET 0
  301:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  302:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  303:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  304:     0004                        TRA_VARSIZE:
  305:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  306:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  307:                                 
  308:     2320 3B                     triggerAlarm: pshd
  309:     2321 1B 9C                     leas -TRA_VARSIZE,SP
  310:     2323 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  311:                                                              ; byte dobel;
  312:                                                              ; byte input;
  313:     2327                        tra_while:                   ; while(!done)
  314:     2327 E7 80                     tst TRA_DONE,SP         ; {
  315:     2329 26 38                     bne tra_endwhile
  316:     232B C6 07                     ldb #BEL                  ;    putchar(BEL);
  317:     232D 87                        clra
  318:     232E 15 FB CB54                jsr [putchar, PCr]
  319:     2332 CC 03E8                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  320:     2335 16 2456                   jsr setDelay
  321:     2338 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  322:     233C                        tra_while2:                  ;    while(!doneInput) 
  323:     233C E7 82                     tst TRA_DONEINPUT,SP      ;    {
  324:     233E 26 21                     bne tra_endwhile2
  325:     2340 16 245A                   jsr polldelay             ;       doneInput = delay();
  326:     2343 6A 82                     staa TRA_DONEINPUT,SP
  327:     2345 16 2372                   jsr pollReadKey           ;       input = pollReadKey();  // check if code entered to disarm
  328:     2348 6B 83                     stab TRA_INPUT,SP
  329:     234A 180F                      tba
  330:     234C 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  331:     234E 27 08                     beq tra_blk1
  332:     2350 16 2483                   jsr isdigit
  333:     2353 97                        tsta
  334:     2354 26 02                     bne tra_blk1
  335:     2356 20 07                     bra tra_endif   
  336:     2358                        tra_blk1:
  337:     2358 A6 83                     ldaa TRA_INPUT,SP
  338:     235A 16 229F                   jsr checkCode             ;                done = checkCode(input);
  339:     235D 6A 80                     staa TRA_DONE,SP 
  340:     235F                        tra_endif: 
  341:     235F 20 DB                     bra tra_while2
  342:     2361                        tra_endwhile2                ;    }
  343:     2361 20 C4                     bra tra_while
  344:     2363                        tra_endwhile                 ; }
  345:     2363 1B 84                     leas TRA_VARSIZE,SP
  346:     2365 3A                        puld
  347:     2366 3D                        rts
  348:                                 
  349:                                 ;-------------------------------------------------------------------------
  350:                                 ; Data Structures
  351:                                 ;-------------------------------------------------------------------------
  352:                                         SWITCH globalConst
  353:                                 ; Message strings
  354:     252A 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           2530 00 
  355:     2531 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           2537 6D 69 6E 67 20 2A 
           253D 2A 2A 0A 0D 00 
  356:     2542 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           2548 6D 65 64 20 2A 2A 
           254E 2A 0A 0D 00 
  357:     2552 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           2558 61 72 6D 69 6E 67 
           255E 20 2D 2D 0A 0D 00 
  358:                                 
  359:                                    switch globalVar
  360:     3000 03E8                   mult dc.w 1000
  361:     3002 0000                   alarmCode dc.w 0
  132:                                  INCLUDE keyPad.asm
    1:                                 ;----------------------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author:
    4:                                 
    5:                                 ; Description:
    6:                                 ;  This contains the code for reading the
    7:                                 ;  16-key keypad attached to Port A
    8:                                 ;  See the schematic of the connection in the
    9:                                 ;  design document.
   10:                                 ;
   11:                                 ;  The following subroutines are provided by the module
   12:                                 ;
   13:                                 ; char pollReadKey(): to poll keypad for a keypress
   14:                                 ;                 Checks keypad for 2 ms for a keypress, and
   15:                                 ;                 returns NOKEY if no keypress is found, otherwise
   16:                                 ;                 the value returned will correspond to the
   17:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   18:                                 ; void initkey(): Initialises Port A for the keypad
   19:                                 ;
   20:                                 ; char readKey(): to read the key on the keypad
   21:                                 ;                 The value returned will correspond to the
   22:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   23:                                 ;---------------------------------------------------------------------
   24:                                 
   25:                                 ; Include header files
   26:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
   27:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   28:                                 
   29:                                 **************EQUATES**********
   30:                                 
   31:                                 ;-----Conversion table
   32:          =00000010              NUMKEYS EQU     16      ; Number of keys on the keypad
   33:          =000000FF              BADCODE         EQU     $FF     ; returned of translation is unsuccessful
   34:          =00000000              NOKEY           EQU     $00   ; No key pressed during poll period
   35:          =00000001              POLLCOUNT       EQU     1     ; Number of loops to create 1 ms poll time
   36:                                 
   37:                                  SWITCH globalConst  ; Constant data
   38:                                 
   39:                                 
   40:                                 
   41:                                  SWITCH code_section  ; place in code section
   42:                                 ;-----------------------------------------------------------    
   43:                                 ; Subroutine: initKeyPad
   44:                                 ;
   45:                                 ; Description: 
   46:                                 ;       Initiliases PORT A
   47:                                 ;       Bits 0-3 as inputs
   48:                                 ;       Bits 4-7 as ouputs
   49:                                 ;       Enable pullups 
   50:                                 ;-----------------------------------------------------------    
   51:     2367                        initKeyPad:
   52:     2367 180B F0 0002                   movb #$f0,DDRA ; Data Direction Register
   53:     236C 180B 01 000C                   movb #$01,PUCR; Enable pullups
   54:     2371 3D                             rts
   55:                                 
   56:                                 ;-----------------------------------------------------------    
   57:                                 ; Subroutine: ch <- pollReadKey
   58:                                 ; Parameters: none
   59:                                 ; Local variable:
   60:                                 ; Returns
   61:                                 ;       ch: NOKEY when no key pressed,
   62:                                 ;       otherwise, ASCII Code in accumulator B
   63:                                 
   64:                                 ; Description:
   65:                                 ;  Loops for a period of 2ms, checking to see if
   66:                                 ;  key is pressed. Calls readKey to read key if keypress 
   67:                                 ;  detected (and debounced) on Port A and get ASCII code for
   68:                                 ;  key pressed.
   69:                                 ;-----------------------------------------------------------
   70:                                 ; Stack Usage
   71:                                         OFFSET 0  ; to setup offset into stack
   72:     0000 +0001                  PRK_CH         DS.B 1 ; return value, ASCII code
   73:     0001                        PRK_VARSIZE:
   74:     0001 +0002                  PRK_PR_X       DS.W 1 ; preserve X
   75:     0003 +0002                  PRK_RA         DS.W 1 ; return address 
   76:                                 
   77:     2372 34                     pollReadKey: pshx   ; preserve register
   78:     2373 1B 9F                     leas -PRK_VARSIZE,SP
   79:     2375 1808 80 00                movb #NOKEY,PRK_CH,SP ; ch = NOKEY;
   80:     2379 CE 0001                   ldx #POLLCOUNT   ; count = POLLCOUNT;
   81:     237C 180B 0F 0000              movb #$0f,PORTA ; PORTA = 0x0f; //set outputs to low
   82:     2381                        prk_loop:           ;           do {
   83:     2381                        prk_if1:
   84:     2381 D6 00                     ldab PORTA        ;      if(PORTA != 0x0f)
   85:     2383 C1 0F                     cmpb #$0f        ;       {
   86:     2385 27 13                     beq prk_endif   ; 
   87:     2387 CC 0001                   ldd #1           ;                 delayms(1)
   88:     238A 16 244F                   jsr delayms     ;              
   89:     238D                        prk_if2:            ;             
   90:     238D D6 00                     ldab PORTA        ;                 if(PORTA != 0x0f)
   91:     238F C1 0F                     cmpb #$0f        ;                 {
   92:     2391 27 07                     beq prk_endif
   93:     2393 16 23A3                   jsr readKey      ;                     ch = readKey();
   94:     2396 6B 80                     stab PRK_CH,SP   ;
   95:     2398 20 03                     bra prk_endloop  ;                     break;
   96:     239A                        prk_endif:         ;              }
   97:     239A 09                        dex              ;          count--;
   98:     239B 26 E4                     bne prk_loop       ;        } while(count!=0);
   99:     239D                        prk_endloop: 
  100:     239D E6 80                     ldab PRK_CH,SP   ; return(ch); in B - Acummulator
  101:                                 ; Restore stack and registers
  102:     239F 1B 81                     leas PRK_VARSIZE,SP
  103:     23A1 30                        pulx
  104:     23A2 3D                        rts
  105:                                 
  106:                                 ;-----------------------------------------------------------    
  107:                                 ; Subroutine: ch <- readKey
  108:                                 ; Arguments: none
  109:                                 ; Local variable: 
  110:                                 ;       ch - ASCII Code in accumulator B
  111:                                 
  112:                                 ; Description:
  113:                                 ;  Main subroutine that reads a code from the
  114:                                 ;  keyboard using the subroutine readKeybrd.  The
  115:                                 ;  code is then translated with the subroutine
  116:                                 ;  translate to get the corresponding ASCII code.
  117:                                 ;-----------------------------------------------------------    
  118:                                 ; Stack Usage
  119:                                         OFFSET 0  ; to setup offset into stack
  120:     0000 +0001                  RK_TMP       DS.B 1 ; code variable
  121:     0001                        RK_VARSIZE:    
  122:     0001 +0002                  RK_RA         DS.W 1 ; return address
  123:                                 
  124:     23A3 1B 9F                  readKey:leas -RK_VARSIZE,SP ; 
  125:     23A5                        rk_loop                     ; do{
  126:     23A5 180C 000F 0000             movb $0F,PORTA         ;    PORTA = 0x0F;
  127:     23AB                        rk_while1:
  128:     23AB D6 00                      ldab PORTA         ;    while(PORTA==0x0F) 
  129:     23AD C1 0F                      cmpb #$0F
  130:     23AF 27 FA                      beq rk_while1
  131:     23B1 1809 80 0000               movb PORTA,RK_TMP,SP ;    tmp = PORTA;
  132:     23B6 CC 000A                    ldd #10
  133:     23B9 16 244F                    jsr delayms            ;    delayms(10); Debouncing Key press
  134:     23BC D6 00                      ldab PORTA             ; 
  135:     23BE E1 80                      cmpb RK_TMP,SP                      ;
  136:     23C0 26 E3                      bne rk_loop                         ;} while(tmp != PORTA); 
  137:     23C2 16 23E0                    jsr keyPress       ; tmp = keyPress();  // get the keycode
  138:     23C5 6B 80                      stab RK_TMP,SP
  139:     23C7 180B 0F 0000               movb #$0F,PORTA        ; PORTA = 0x0F;  // set all output pins to 0
  140:     23CC                        rk_while2: 
  141:     23CC D6 00                      ldab PORTA         ; while(PORTA!=0F)
  142:     23CE C1 0F                      cmpb #$0F                   ;{
  143:     23D0 26 FA                      bne rk_while2
  144:     23D2 CC 000A                    ldd #10
  145:     23D5 16 244F                    jsr delayms            ; delayms(10);  // Debouncing release of the key
  146:     23D8 E6 80                      ldab RK_TMP,SP                      ;} 
  147:     23DA 16 240F                    jsr translate          ; ch = translate(tmp);
  148:     23DD 1B 81                      leas RK_VARSIZE,SP
  149:     23DF 3D                         rts                    ;  return(ch); 
  150:                                 
  151:                                 ;-----------------------------------------------------------    
  152:                                 ; Subroutine: key <- keyPress       
  153:                                 ; Arguments: none
  154:                                 ; Local variables:  key: Accumulator B
  155:                                 ; Returns: key - in Accumulator B - code corresponding to key pressed
  156:                                 
  157:                                 ; Description: Assume key is pressed. Set 0 on each output pin
  158:                                 ;              to find row and hence code for the key.
  159:                                 ;-----------------------------------------------------------    
  160:                                 ; codes for scanning keyboard
  161:                                 
  162:          =000000EF              ROW1 EQU %11101111
  163:          =000000DF              ROW2 EQU %11011111
  164:          =000000BF              ROW3 EQU %10111111
  165:          =0000007F              ROW4 EQU %01111111
  166:                                 
  167:     23E0 180B EF 0000           keyPress: movb #ROW1,PORTA  ; PORTA = ROW1;
  168:     23E5                        kp_if1:
  169:     23E5 D6 00                      ldab PORTA          ; if(PORTA == ROW1) 
  170:     23E7 C1 EF                      cmpb #ROW1
  171:     23E9 26 21                      bne kp_endif      ; {
  172:     23EB 180B DF 0000               movb #ROW2,PORTA  ;   PORTA = ROW2
  173:     23F0                        kp_if2:
  174:     23F0 D6 00                      ldab PORTA          ;   if(PORTA == ROW2)
  175:     23F2 C1 DF                      cmpb #ROW2
  176:     23F4 26 16                      bne kp_endif      ;   {
  177:     23F6 180B BF 0000               movb #ROW3,PORTA  ;      PORTA = ROW3;
  178:     23FB                        kp_if3:
  179:     23FB D6 00                      ldab PORTA          ;      if(PORTA == ROW3)
  180:     23FD C1 BF                      cmpb #ROW3        ;        {
  181:     23FF 26 0B                      bne kp_endif      ;          PORTA = ROW4;
  182:     2401 180B 7F 0000               movb #ROW4,PORTA  ;        }
  183:     2406 C1 7F                      cmpb #ROW4
  184:     2408 26 02                      bne kp_endif 
  185:     240A 20 D4                      bra keyPress
  186:     240C                        kp_endif:                  ;   }                                                    
  187:                                                         ; }
  188:     240C D6 00                      ldab PORTA        ; key = PORTA;
  189:     240E 3D                         rts               ; return(key);
  190:                                               
  191:                                 ;-----------------------------------------------------------    
  192:                                 ; Subroutine:  ch <- translate(code)
  193:                                 ; Arguments
  194:                                 ;       code - in Acc B - code read from keypad port
  195:                                 ; Returns
  196:                                 ;       ch - saved on stack but returned in Acc B - ASCII code
  197:                                 ; Local Variables
  198:                                 ;       ptr - in register X - pointer to the table
  199:                                 ;       count - counter for loop in accumulator A
  200:                                 ; Description:
  201:                                 ;   Translates the code by using the conversion table
  202:                                 ;   searching for the code.  If not found, then BADCODE
  203:                                 ;   is returned.
  204:                                 ;-----------------------------------------------------------    
  205:                                 ; Stack Usage:
  206:                                    OFFSET 0
  207:     0000 +0001                  TR_CH DS.B 1  ; for ch 
  208:     0001                        TR_VARSIZE:
  209:     0001 +0001                  TR_PR_A DS.B 1 ; preserved regiters A
  210:     0002 +0001                  TR_PR_X DS.B 1 ; preserved regiters X
  211:     0003 +0002                  TR_RA DS.W 1 ; return address
  212:                                 
  213:     240F 34                     translate: pshx
  214:     2410 36                             psha    ; preserve registers
  215:     2411 1B 9F                          leas -TR_VARSIZE,SP                 ; 
  216:     2413 CE 242F                        ldx #cnvTbl                 ; ptr = cnvTbl;
  217:     2416 1808 80 FF                     movb #BADCODE,TR_CH,SP ; ch = BADCODE;
  218:     241A 87                             clra                        ; ix = 0;
  219:     241B                        tr_for:                             ; for(i=0;i<NUMKEYS;i++) {
  220:     241B E1 00                          cmpb cnvTbl_code,X          ;     if(code == ptr->code)
  221:     241D 26 06                          bne tr_endif                ;     {
  222:     241F 180A 01 80                     movb cnvTbl_ascii,X,TR_CH,SP ;        ch <- [ptr+1]
  223:     2423 20 07                          bra TR_end                  ;         break;
  224:     2425                        tr_endif:                           ;     }
  225:                                                                     ;     else {        
  226:     2425 1A 02                          leax cnvTbl_struct_len,X    ;           ptr++;
  227:     2427 42                             inca ;    
  228:     2428 81 10                          cmpa #NUMKEYS               ;} 
  229:     242A 25 EF                          blo tr_for;
  230:     242C                        tr_end ; 
  231:                                 
  232:                                         ; restore registres
  233:     242C 32                             pula
  234:     242D 30                             pulx
  235:     242E 3D                             rts
  236:                                         
  237:                                 ; defnitions for structure cnvTbl_struct
  238:                                  OFFSET 0
  239:     0000 +0001                  cnvTbl_code DS.B 1
  240:     0001 +0001                  cnvTbl_ascii  DS.B 1
  241:          =00000002              cnvTbl_struct_len EQU *
  242:                                 
  243:                                 ; Conversion Table
  244:     242F EE 31                  cnvTbl:  dc.b %11101110,'1'
  245:     2431 ED 32                          dc.b %11101101,'2'
  246:     2433 EB 33                          dc.b %11101011,'3'
  247:     2435 E7 61                          dc.b %11100111,'a'
  248:     2437 DE 34                          dc.b %11011110,'4'
  249:     2439 DD 35                          dc.b %11011101,'5'
  250:     243B DB 36                          dc.b %11011011,'6'
  251:     243D D7 62                          dc.b %11010111,'b'
  252:     243F BE 37                          dc.b %10111110,'7'
  253:     2441 BD 38                          dc.b %10111101,'8'
  254:     2443 BB 39                          dc.b %10111011,'9'
  255:     2445 B7 63                          dc.b %10110111,'c'
  256:     2447 7E 2A                          dc.b %01111110,'*'
  257:     2449 7D 30                          dc.b %01111101,'0'
  258:     244B 7B 23                          dc.b %01111011,'#'
  259:     244D 77 64                          dc.b %01110111,'d'
  133:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: 
    6:                                 ; Date: 
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                 ; Some definitions
   10:          =00000BB8              COUNT equ 3000
   11:                                         SWITCH code_section
   12:                                 
   13:                                 ;-------------------------------
   14:                                 ; Subroutine delayms
   15:                                 ; Parameters: num - number of milliseconds to delay - in accumulator D
   16:                                 ; Returns: nothing
   17:                                 ; Global Variables:
   18:                                 ; Description: Delays for num ms. 
   19:                                 ;--------------------------------
   20:                                 
   21:     244F                        delayms:
   22:     244F                        delayms_while:;do{
   23:     244F 16 2476                        jsr delay1ms; dealy1ms();
   24:     2452 04 34 FA                       dbne d, delayms_while;num--;}while(num!=0);
   25:     2455 3D                             rts
   26:                                         
   27:                                 ;------------------------------------------------------
   28:                                 ; Subroutine setDelay
   29:                                 ; Parameters: cnt - accumulator D
   30:                                 ; Returns: nothing
   31:                                 ; Global Variables: delayCount
   32:                                 ; Description: Intialises the delayCount 
   33:                                 ;              variable.
   34:                                 ;------------------------------------------------------
   35:     2456                        setDelay: 
   36:     2456 7C 3004                        std delayCount ; delayCount = counter  
   37:     2459 3D                             rts     
   38:                                 
   39:                                 ;------------------------------------------------------
   40:                                 ; Subroutine: polldelay
   41:                                 ; Parameters:  none
   42:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   43:                                 ; Local Variables
   44:                                 ;   retval - acc A 
   45:                                 ;   retval 
   46:                                 ; Global Variables:
   47:                                 ;      delayCount
   48:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   49:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   50:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   51:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   52:                                 ;   Need 24 cyles to create 1 microsecond delay
   53:                                 ;   8 cycles creates a 333 1/3 nano delay
   54:                                 ;       DEX - 1 cycle
   55:                                 ;       BNE - 3 cyles - when branch is taken
   56:                                 ;       Need 4 NOP
   57:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   58:                                 ;------------------------------------------------------
   59:                                 ; Stack Usage:
   60:                                         OFFSET 0  ; to setup offset into stack
   61:     0000 +0001                  PDLY_RETVAL DS.B 1; 
   62:     0001                        PDLY_VARSIZE:
   63:     0001 +0002                  PDLY_PR_Y   DS.W 1 ; preserve Y register
   64:     0003 +0002                  PDLY_RA     DS.W 1 ; return address
   65:                                 
   66:     245A 35                     polldelay: pshy  
   67:     245B 1B 9F                          leas -PDLY_VARSIZE,SP
   68:     245D 1808 80 00                     movb #FALSE,PDLY_RETVAL,SP ; byte retval = FALSE;
   69:     2461 16 2476                        jsr delay1ms               ; delay1ms(); 
   70:     2464 73 3004                        dec delayCount             ; delayCount--; 
   71:     2467 F7 3004                        tst delayCount             ;if (delayCount==0)
   72:     246A 26 04                          bne polldelay_endif        ; 
   73:     246C 1808 80 01                     movb #TRUE,PDLY_RETVAL,SP ; retval = TRUE;
   74:     2470                                polldelay_endif: 
   75:     2470 A6 80                          ldaa PDLY_RETVAL,SP
   76:                                         ; restore registers and stack 
   77:     2472 1B 9F                          leas -PDLY_VARSIZE,SP 
   78:     2474 31                             puly   
   79:     2475 3D                             rts  
   80:                                 
   81:                                 ;------------------------------------------------------
   82:                                 ; Subroutine: delay1ms
   83:                                 ; Parameters:  none
   84:                                 ; Returns: none
   85:                                 ; Local Variables
   86:                                 ;   
   87:                                 ; Global Variables:
   88:                                 ;      COUNT - Number of loops -in register X
   89:                                 ; Description: 
   90:                                 ;   The subroutine delays for 1 ms.
   91:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   92:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   93:                                 ;   Need 24 cyles to create 1 microsecond delay
   94:                                 ;   8 cycles creates a 333 1/3 nano delay
   95:                                 ;       DEX - 1 cycle
   96:                                 ;       BNE - 3 cyles - when branch is taken
   97:                                 ;       Need 4 NOP
   98:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   99:                                 ;------------------------------------------------------
  100:                                 ; Stack Usage:
  101:     2476 34                     delay1ms:pshx
  102:     2477 CE 0BB8                        ldx #COUNT    ;cnt = COUNT
  103:     247A                                delay1ms_loop:; do 
  104:     247A A7                             NOP           ;{
  105:     247B A7                             NOP                             ;                       
  106:     247C A7                             NOP                             ;
  107:     247D A7                             NOP            ; 
  108:     247E 09                             DEX            ; cnt--
  109:     247F 26 F9                          bne delay1ms_loop;}while(cnt!=0)
  110:                                         ; restore registers   
  111:     2481 30                             pulx
  112:     2482 3D                             rts
  113:                                 
  114:                                 ;------------------------------------------------------
  115:                                 ; Global variables
  116:                                 ;------------------------------------------------------
  117:                                    switch globalVar
  118:     3004 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  119:                                 
  134:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     2483 37                     isdigit: pshb   ; save B on stack
   20:     2484 180E                      tab          ; save Parameter in B
   21:     2486 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     2488 C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     248A 25 06                     blo ISD_endif
   24:     248C C1 39                     cmpb #'9'
   25:     248E 22 02                     bhi ISD_endif
   26:     2490 86 01                     ldaa #TRUE
   27:     2492                        ISD_endif:
   28:     2492 33                        pulb         ; restore B
   29:     2493 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     2494 36                     polgetchar: psha     ; gechar destroys contents of acc A
   46:     2495 C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     2497 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     249B 15 FB C9E5               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     249F                        PGC_endif
   51:     249F 32                        pula            ; restore registers
   52:     24A0 3D                        rts             ; return(chr);  in ACC B
  135:                                  INCLUDE switches.asm
    1:                                 ;-------------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File:  switches.asm
    4:                                 ; Description: This file contains the Switches module for the
    5:                                 ;              Alarm System project.
    6:                                 ;-----------------------------------------------------------------*/
    7:                                 ; Include header files
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   10:                                 
   11:                                  SWITCH code_section  ; place in code section
   12:                                 ;----------------------------------------
   13:                                 ; Subroutine: initSwitches
   14:                                 ; Parameters: none
   15:                                 ; Returns: nothing
   16:                                 ; Description: Initialises the port for monitoring the switches
   17:                                 ;              and controlling LEDs.
   18:                                 ;----------------------------------------
   19:     24A1                        initSwitches:        
   20:     24A1 79 0262                   clr  DDRH         ; DDRH = 0; // set to input (switches)
   21:     24A4 180B FF 0264              movb #$ff,PERH     ; PERH = 0xff; // Enable pull-up/pull-down 
   22:     24A9 79 0265                   clr  PPSH     ; PPSH = 0x00; // pull-up device connected to H
   23:                                                      ;             // switches ground the pins when closed.
   24:     24AC 3D                        rts
   25:                                 
   26:                                 ;------------------------
   27:                                 ; Subrooutine: getSwStatus
   28:                                 ; Parameters:  none
   29:                                 ; Returns: Acc A - An 8 bit code that indicates which
   30:                                 ;          switches are opened (bit set to 1).
   31:                                 ; Description: Checks status of switches and 
   32:                                 ;              returns bytes that shows their
   33:                                 ;              status.      
   34:                                 ;---------------------------
   35:     24AD                        getSwStatus:
   36:     24AD B6 0260                    ldaa PTH   ;return(PTH);
   37:     24B0 3D                         rts
  136:                                 
  137:                                    switch code_section
  138:     24B1                        ENDCODE ;  used to define where the dataEEPROM section starts
  139:                                         end                ; end of program

Symbols:
alarmcode                       *00003002
alarmcodes                      *000024b1
armdelay                        *00000bb8
armed                           *00002542
arming                          *00002531
ascii_conv_num                  *00000030
badcode                         *000000ff
beepdelay                       *000003e8
bel                             *00000007
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *00002316
cdv_endwhile                    *0000231a
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *0000230a
cerrmsg                         *000024ff
cfg_else2                       *00002096
cfg_elseif2                     *00002088
cfg_endif1                      *000020a5
cfg_endif2                      *000020a1
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *0000206b
cfg_varsize                     *00000003
checkcode                       *0000229f
ckc_else                        *000022e6
ckc_endif                       *000022f2
ckc_endif1                      *000022e4
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
cnvtbl                          *0000242f
cnvtbl_ascii                    *00000001
cnvtbl_code                     *00000000
cnvtbl_struct_len               *00000002
codemsg                         *0000252a
configcodes                     *00002062
configmsg                       *000024ec
count                           *00000bb8
cr                              *0000000d
crgflg                          *00000037
ddra                            *00000002
ddrh                            *00000262
delay1ms                        *00002476
delay1ms_loop                   *0000247a
delaycount                      *00003004
delayms                         *0000244f
delayms_while                   *0000244f
disarming                       *00002552
eal_blk1                        *0000220d
eal_blk2                        *0000223f
eal_blk3                        *00002281
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *0000226e
eal_elseifa                     *00002247
eal_elseifb                     *0000228b
eal_endelseif                   *00002299
eal_endelseifb                  *00002299
eal_endif1                      *0000221b
eal_endif2                      *0000221b
eal_endif3                      *00002228
eal_endif4                      *00002287
eal_endif5                      *00002287
eal_endwhile1                   *000021dc
eal_endwhile2                   *0000221d
eal_endwhile3                   *0000229b
eal_endwhile4                   *00002289
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000021ca
eal_while2                      *000021f1
eal_while3                      *00002228
eal_while4                      *0000225b
emc_alarmcode                   *00000003
emc_endfor                      *00002100
emc_endif2                      *000020f7
emc_endif3                      *000020f7
emc_for                         *000020c5
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000021bc
endcode                         *000024b1
entermstcode                    *000020a9
err_mst_msg                     *00002519
false                           *00000000
get_code_msg                    *0000250b
getchar                         *0000ee84
getswstatus                     *000024ad
inithw                          *0000202c
initkeypad                      *00002367
initswitches                    *000024a1
iscodevalid                     *000022fa
isd_endif                       *00002492
isdigit                         *00002483
keypress                        *000023e0
kp_endif                        *0000240c
mainloop                        *0000200b
menu                            *000024bb
mnelse                          *00002029
mnelseif                        *00002020
mnendif                         *00002029
mstcdmsg                        *000024de
mult                            *00003000
nl                              *0000000a
nochar                          *000000ff
nokey                           *00000000
numcodes                        *00000005
numkeys                         *00000010
pdly_retval                     *00000000
pdly_varsize                    *00000001
perh                            *00000264
pgc_endif                       *0000249f
pllctl                          *0000003a
pollcount                       *00000001
polldelay                       *0000245a
polldelay_endif                 *00002470
pollreadkey                     *00002372
porta                           *00000000
ppsh                            *00000265
printf                          *0000ee88
prk_ch                          *00000000
prk_endif                       *0000239a
prk_endloop                     *0000239d
prk_loop                        *00002381
prk_varsize                     *00000001
program                         *00002000
pth                             *00000260
pucr                            *0000000c
putchar                         *0000ee86
readkey                         *000023a3
refdv                           *00000035
regblk                          *00000000
rk_loop                         *000023a5
rk_tmp                          *00000000
rk_varsize                      *00000001
rk_while1                       *000023ab
rk_while2                       *000023cc
row1                            *000000ef
row2                            *000000df
row3                            *000000bf
row4                            *0000007f
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00002176
setc_else2                      *0000213f
setc_elseif                     *0000214c
setc_endfor                     *00002188
setc_endif                      *0000217f
setc_endif2                     *0000214a
setc_flag                       *00000001
setc_for                        *00002127
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *0000211e
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00002108
setdelay                        *00002456
stack                           *00002000
synr                            *00000034
tr_ch                           *00000000
tr_end                          *0000242c
tr_endif                        *00002425
tr_for                          *0000241b
tr_varsize                      *00000001
tra_blk1                        *00002358
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *0000235f
tra_endwhile                    *00002363
tra_endwhile2                   *00002361
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *00002327
tra_while2                      *0000233c
translate                       *0000240f
triggeralarm                    *00002320
true                            *00000001
variables                       *00003000
wait_b3                         *00002043
wree_pr_d                       *00000000
wree_pr_x                       *00000002
writeeebyte                     *0000eea6
writetoee                       *0000219e

