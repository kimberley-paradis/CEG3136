;----------------------------------------------------------------------
; File: Keypad.asm
; Author:

; Description:
;  This contains the code for reading the
;  16-key keypad attached to Port A
;  See the schematic of the connection in the
;  design document.
;
;  The following subroutines are provided by the module
;
; char pollReadKey(): to poll keypad for a keypress
;                 Checks keypad for 2 ms for a keypress, and
;                 returns NOKEY if no keypress is found, otherwise
;                 the value returned will correspond to the
;                 ASCII code for the key, i.e. 0-9, *, # and A-D
; void initkey(): Initialises Port A for the keypad
;
; char readKey(): to read the key on the keypad
;                 The value returned will correspond to the
;                 ASCII code for the key, i.e. 0-9, *, # and A-D
;---------------------------------------------------------------------

; Include header files
 include "sections.inc"
 include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports

**************EQUATES**********

;-----Conversion table
NUMKEYS	EQU	16	; Number of keys on the keypad
BADCODE 	EQU	$FF 	; returned of translation is unsuccessful
NOKEY		EQU 	$00   ; No key pressed during poll period
POLLCOUNT	EQU	1     ; Number of loops to create 1 ms poll time

 SWITCH globalConst  ; Constant data

; codes for scanning keyboard

ROW1 EQU %11101111
ROW2 EQU %11011111
ROW3 EQU %10111111
ROW4 EQU %01111111


 SWITCH code_section  ; place in code section
;-----------------------------------------------------------	
; Subroutine: initKeyPad
;
; Description: 
; 	Initiliases PORT A
; 	Bits 0-3 as inputs
; 	Bits 4-7 as ouputs
; 	Enable pullups 
;-----------------------------------------------------------	
initKeyPad:
	movb #$f0,DDRA ; Data Direction Register
	movb #$01,PUCR; Enable pullups
	rts

;-----------------------------------------------------------    
; Subroutine: ch <- pollReadKey
; Parameters: none
; Local variable: code - in accumulator B
;    ch - in accumulator B - char returned
;    count - index reg X - count to create
;                          10 ms delay
; Returns
;       ch: NOKEY when no key pressed,
;       otherwise, ASCII Code in accumulator B

; Description:
;  Loops for a period of 2ms, checking to see if
;  key is pressed. Calls readKey to read key if keypress 
;  detected (and debounced) on Port A.
;  When no key pressed, loop takes 11 cycles.
;       1 loop takes 11 X 41 2/3 nano-seconds = 458 1/3 ns
;       1 ms delay requires 2182 loops - set to POLLCOUNT
;-----------------------------------------------------------
; Stack Usage
	OFFSET 0  ; to setup offset into stack
PRK_CH         DS.B 1 ; return value, ASCII code
PRK_VARSIZE
PRK_PR_X       DS.W 1 ; preserve X
PRK_RA         DS.W 1 ; return address 

pollReadKey: pshx   ; preserve register
   leas -PRK_VARSIZE,SP
   movb #NOKEY,PRK_CH,SP ; ch = NOKEY;
   ldx #POLLCOUNT   ; count = POLLCOUNT;
   movb #$0f,PORTA  ; PORTA = 0x0f; //set outputs to low
prk_loop:           ;           do {
prk_if1:
   ldab PORTA       ;       if(PORTA != 0x0f)
   cmpb #$0f        ;       {
   beq prk_endif1   ; 
   ldd #1           ;                 delayms(1)
   jsr delayms      ;              
prk_if2:            ;             
   ldab PORTA       ;                  if(PORTA != 0x0f)
   cmpb #$0f        ;                 {
   beq prk_endif2
   jsr readKey      ;                     ch = readKey();
   stab PRK_CH,SP
   ldab PRK_CH,SP   ;
   bra prk_endloop  ;                     return (ch)
prk_endif1:         ;                 }
prk_endif2:         ;              }
   dex              ;          count--;
   bne prk_loop	    ;        } while(count!=0);
prk_endloop: 
   ldab PRK_CH,SP   ; return(ch);
   ; Restore stack and registers
   leas PRK_VARSIZE,SP
   pulx
   rts

;-----------------------------------------------------------	
; Subroutine: ch <- readKey
; Arguments: none
; Local variable: code - on stack
;                 ch - accumulator B
; Returns
;	ch - ASCII Code in accumulator B

; Description:
;  Main subroutine that reads a code from the
;  keyboard using the subroutine readKeyCode.  The
;  code is then translated with the subroutine
;  translate to get the corresponding ASCII code.
;-----------------------------------------------------------	
; Stack Usage
	OFFSET 0  ; to setup offset into stack
RK_CODE       DS.B 1 ; code variable
RK_VARSIZE:    
RK_PR_A       DS.B 1 ; Preseserve A
RK_RA         DS.W 1 ; return address

readKey:psha		; byte code;	
    leas -RK_VARSIZE,SP ; load effective address to stack pointer
rkDo                     ; do	           ; {
    movb $0F,PORTA         ;    PORTA = 0x0F;
rkLop1:
    ldab PORTA         ;    while(PORTA==0x0F) 
    cmpb #$0F
    beq rkLop1
    movb PORTA,RK_CODE,SP ;    code = PORTA
    ldd #10
    jsr delayms	           ;    delayms(10);
    ldab PORTA	           ; } while(code != PORTA); 
    cmpb RK_CODE,SP
    bne rkDo
    jsr keyPress       ; code = readKeyCode();  // get the keycode
    stab RK_CODE,SP
    movb #$0F,PORTA        ; PORTA = 0x0F;  // set all output pins to 0
rkLop2: 
    ldab PORTA         ; while(PORTA!=0F)  /* wait */;
    cmpb #$0F
    bne rkLop2
    ldd #10
    jsr delayms            ; delayms(10);  // Debouncing release of the key
    ldab RK_CODE,SP
    jsr translate          ; ch = translate(code);
    leas RK_VARSIZE,SP
    pula
    rts		           ;  return(ch); 

;-----------------------------------------------------------	
; Subroutine: key <- keyPress       
; Arguments: none
; Local variables:  key: Accumulator B
; Returns: key - in Accumulator B - code corresponding to key pressed

; Description: Assume key is pressed. Set 0 on each output pin
;              to find row and hence code for the key.
;-----------------------------------------------------------	
; Stack Usage: none

keyPress: 
         movb #ROW1,PORTA  ; PORTA = ROW1;
kpIf1  ldab PORTA          ; if(PORTA == ROW1) // input pin is 0 if key in row 1
         cmpb #ROW1
         bne kpEndIf1      ; {
         movb #ROW2,PORTA  ;   PORTA = ROW2
kpIf2  ldab PORTA          ;   if(PORTA == ROW2)
         cmpb #ROW2
         bne kpEndIf2      ;   {
         movb #ROW3,PORTA  ;      PORTA = ROW3;
kpIf3  ldab PORTA          ;      if(PORTA == ROW3)
         cmpb #ROW3        ;        {
         bne kpEndIf3      ;          PORTA = ROW4;
         movb #ROW4,PORTA  ;        }
kpEndIf1 		   ;   }
kpEndIf2 
kpEndIf3                                                    
                           ; }
         ldab PORTA        ; key = PORTA;
         rts               ; return(key);
	      
;-----------------------------------------------------------	
; Subroutine:  ch <- translate(code)
; Arguments
;	code - in Acc B - code read from keypad port
; Returns
;	ch - saved on stack but returned in Acc B - ASCII code
; Local Variables
;    	ptr - in register X - pointer to the table
;	count - counter for loop in accumulator A
; Description:
;   Translates the code by using the conversion table
;   searching for the code.  If not found, then BADCODE
;   is returned.
;-----------------------------------------------------------	
; Stack Usage:

translate:
	cmpb #%11101110
	beq store1
	cmpb #%11101101
	beq store2
	cmpb #%11101011
	beq store3
	cmpb #%11100111
	beq storeA
	
	cmpb #%11011110
	beq store4
	cmpb #%11011101
	beq store5
	cmpb #%11011011
	beq store6
	cmpb #%11010111
	beq storeB

	cmpb #%10111110
	beq store7
	cmpb #%10111101
	beq store8
	cmpb #%10111011
	beq store9
	cmpb #%10110111
	beq storeC

	cmpb #%01111110
	beq storeAst
	cmpb #%01111101
	beq store0
	cmpb #%01111011
	beq storeHashtag
	cmpb #%01110111
	beq storeD
	ldb #0;
	rts



store1:
	ldb #'1'
	rts
store2:
	ldb #'2'
	rts;
store3
	ldb #'3'
	rts;
storeA
	ldb #'a'
	rts;
store4
	ldb #'4'
	rts
store5
	ldb #'5'
	rts
store6
	ldb #'6'
	rts
storeB
	ldb #'b'
	rts
store7
	ldb #'7'
	rts
store8
	ldb #'8'
	rts
store9
	ldb #'9'
	rts
storeC
	ldb #'c';
	rts
storeAst
	ldb #'*'
	rts;
store0
	ldb #'0'
	rts;
storeHashtag
	ldb #'#'
	rts
storeD
	ldb #'d'
	rts